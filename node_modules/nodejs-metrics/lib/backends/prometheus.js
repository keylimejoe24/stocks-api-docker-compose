"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrometheusMetricsBackend = void 0;
const net_1 = require("net");
const express_1 = __importDefault(require("express"));
const prom_client_1 = __importDefault(require("prom-client"));
const constants_1 = require("../constants");
class PrometheusMetricsBackend {
    constructor(settings) {
        const { logger, defaultMetricsTimeout, serverPort, } = { ...constants_1.DefaultBackendSettings, ...settings };
        this.setupServer();
        this.client = prom_client_1.default;
        this.logger = logger || {
            // eslint-disable-next-line no-console
            debug: () => console.debug,
            // eslint-disable-next-line no-console
            info: () => console.log,
            // eslint-disable-next-line no-console
            warn: () => console.warn,
            // eslint-disable-next-line no-console
            error: () => console.error,
            child: () => this.logger,
        };
        this.desiredServerPort = serverPort || 0;
        this.serverPort = -1;
        this.defaultMetricsTimeout = defaultMetricsTimeout || constants_1.DefaultBackendSettings.defaultMetricsTimeout || 0;
    }
    getClient() {
        return this.client;
    }
    getServerPort() {
        return this.serverPort;
    }
    async startServer() {
        let isResolved = false;
        this.serverPort = await this.createServer(this.desiredServerPort);
        await new Promise((resolve, reject) => {
            if (!this.app) {
                throw new Error("'app' has not been initialized");
            }
            this.metricsServer = this.app.listen(this.serverPort, () => {
                isResolved = true;
                this.client.collectDefaultMetrics({ timeout: this.defaultMetricsTimeout });
                resolve(this.metricsServer);
            });
            this.metricsServer.once("error", (err) => {
                this.logger.error(err);
                if (!isResolved) {
                    reject(err);
                }
            });
        });
    }
    async stopServer() {
        return new Promise((resolve, reject) => {
            if (this.metricsServer && this.metricsServer.address() !== null) {
                this.client.register.clear();
                return this.metricsServer.close((err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    if (this.metricsServer) {
                        this.metricsServer.unref();
                        this.metricsServer.removeAllListeners();
                    }
                    resolve();
                });
            }
            resolve();
        });
    }
    setupServer() {
        this.app = express_1.default();
        this.app.get("/metrics", (_req, res) => {
            const metrics = this.client.register.metrics({ timestamps: false });
            res.set("Content-Type", this.client.register.contentType);
            res.end(metrics);
        });
        this.app.get("/", (_req, res) => {
            res.status(200).json({ status: "OK" });
        });
    }
    async createServer(desiredPort) {
        return new Promise((resolve, reject) => {
            const server = net_1.createServer();
            server.once("error", (err) => {
                if (err.code === "EADDRINUSE") {
                    if (desiredPort === 0) {
                        reject(new Error("Cannot allocate random free port"));
                        return;
                    }
                    this.createServer(0).then(resolve, reject);
                    return;
                }
                reject(err);
            });
            server.once("listening", () => {
                const serverPort = server.address().port;
                server.close((err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    resolve(serverPort);
                });
            });
            server.listen(desiredPort);
        });
    }
}
exports.PrometheusMetricsBackend = PrometheusMetricsBackend;
//# sourceMappingURL=prometheus.js.map